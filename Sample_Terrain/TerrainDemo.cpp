#include "TerrainDemo.h"

#include "apoc3d/Core/GameTime.h"
#include "apoc3d/Core/CommandInterpreter.h"
#include "apoc3d/Config/XmlConfigurationFormat.h"

#include "apoc3d/Graphics/RenderSystem/RenderWindow.h"
#include "apoc3d/Graphics/RenderSystem/RenderDevice.h"
#include "apoc3d/Graphics/RenderSystem/RenderStateManager.h"
#include "apoc3d/Graphics/RenderSystem/Sprite.h"
#include "apoc3d/Graphics/RenderSystem/Texture.h"
#include "apoc3d/Graphics/EffectSystem/EffectManager.h"
#include "apoc3d/Graphics/EffectSystem/EffectParameter.h"
#include "apoc3d/Graphics/TextureManager.h"
#include "apoc3d/Graphics/GraphicsCommon.h"
#include "apoc3d/Graphics/PixelFormat.h"
#include "apoc3d/Graphics/ModelManager.h"
#include "apoc3d/Graphics/Model.h"
#include "apoc3d/Graphics/Mesh.h"
#include "apoc3d/Scene/OctreeSceneManager.h"
#include "apoc3d/Scene/SceneRenderer.h"
#include "apoc3d/Input/InputAPI.h"
#include "apoc3d/Input/Keyboard.h"
#include "apoc3d/Input/Mouse.h"
#include "apoc3d/Vfs/FileLocateRule.h"
#include "apoc3d/Vfs/FileSystem.h"
#include "apoc3d/Vfs/Archive.h"
#include "apoc3d/Vfs/ResourceLocation.h"
#include "apoc3d/Vfs/PathUtils.h"
#include "apoc3d/Math/ColorValue.h"
#include "apoc3d/Math/RandomUtils.h"
#include "apoc3d/Math/PerlinNoise.h"
#include "apoc3d/Utility/StringUtils.h"
#include "apoc3d/UILib/Form.h"
#include "apoc3d/UILib/FontManager.h"
#include "apoc3d/UILib/Console.h"
#include "apoc3d/Platform/Thread.h"

#include "GameCamera.h"
#include "Terrain.h"
#include "TerrainMesh.h"
#include "TerrainCommands.h"

using namespace Apoc3D::Config;
using namespace Apoc3D::Graphics;
using namespace Apoc3D::Graphics::EffectSystem;
using namespace Apoc3D::Input;
using namespace Apoc3D::VFS;
using namespace Apoc3D::Utility;


namespace SampleTerrain
{
	TerrainDemo::TerrainDemo(RenderWindow* wnd)
		: Game(wnd), m_allowTakingDownTrees(true), m_isMoving(false), m_isLoading(true), m_sceneContentLoaded(2), 
		m_zeroOpFrameCounter(0), m_helpShowState(0)
	{
		memset(m_terrainBlocks, 0, sizeof(m_terrainBlocks));
	}

	TerrainDemo::~TerrainDemo()
	{		

	}

	void TerrainDemo::Initialize()
	{
		m_window->setTitle(L"Terrain Demo");
		Game::Initialize();

		m_sprite = m_device->getObjectFactory()->CreateSprite();
	}
	void TerrainDemo::Finalize()
	{
		Game::Finalize();
	}

	void TerrainDemo::Load()
	{
		Game::Load();

		{
			// This will change the default FileLocateRule 'Textures' to our own one, which
			// can search in the pak file.
			LocateCheckPoint cp;
			cp.AddPath(L"textures.pak");
			FileLocateRule::Textures.AddCheckPoint(cp);
		}
		{
			// Add a comic font to the font manager. Use of FileLocation is explained here.

			// Locate the file, using "comic.fnt" as the name, FileLocateRule::Default as the rule.
			// In this case, Default is to search the file in the same dir as the application
			FileLocation* fl = FileSystem::getSingleton().Locate(L"comic.fnt", FileLocateRule::Default);

			// Giving the font a name and telling FontManager the location, it will load it.
			FontManager::getSingleton().LoadFont(m_device, L"comic", fl);
		}

		m_console->Minimize();

		// using the effect list generated by the build system, APBuild, is very convenience
		// for only 3 lines of code to load all the shader effects
		FileLocation* fl = FileSystem::getSingleton().Locate(L"effectList.xml", FileLocateRule::Effects);
		EffectManager::getSingleton().LoadEffectFromList(m_device, fl);
		delete fl;
		
		Viewport vp = m_device->getViewport();

		m_camera = new GameCamera(vp.Width/(float)(vp.Height));
		m_camera->setPosition(Vector3Utils::LDVector(100,0,100));
		m_camera->UpdateTransform();

		m_sceneRenderer = new SceneRenderer(m_device);

		// The scene render script is located
		fl = FileSystem::getSingleton().Locate(L"Renderer.xml", FileLocateRule::Default);
		// Then loaded by SceneRenderer
		Configuration* config = XMLConfigurationFormat::Instance.Load(fl);
		m_sceneRenderer->Load(config);
		delete config;
		delete fl;

		m_sceneRenderer->RegisterCamera(m_camera);

		// setting the parameters to be used in shader effects here
		// In this demo, as it is very simple, light source is fixed
		RendererEffectParams::CurrentCamera = m_camera;
		RendererEffectParams::LightDirection = Vector3Utils::LDVector(-0.707f,0.707f,0);

		// our terrain mesh manager, see the header file for details
		TerrainMeshManager::Initialize();
		TerrainMeshManager::getSingleton().InitializeResources(m_device);
		Terrain::NewSeed();

		m_scene = new OctreeSceneManager(OctreeBox(20000), 20000/256);

		RegisterTerrainCommands();
		
		LoadUI();

	}
	void TerrainDemo::LoadScene()
	{
		// load NumBlockOnEdge by NumBlockOnEdge of terrain chunks
		for (int i=MinBlockCoord;i<=MaxBlockCoord;i++)
		{
			for (int j=MinBlockCoord;j<=MaxBlockCoord;j++)
			{
				Terrain* t1 = new Terrain(m_device, i,j);
				m_scene->AddObject(t1);

				m_terrainBlocks[i - MinBlockCoord][j - MinBlockCoord] = t1;
			}
		}

		{
			// now load up the Sky, a sphere mesh. 
			// A big radius ensures its always regarded in sight by the engine.
			StaticObject* obj = new StaticObject();
			obj->setRadius(9999999);

			FileLocateRule rule;
			LocateCheckPoint cp;
			cp.AddPath(L"models");
			rule.AddCheckPoint(cp);

			FileLocation* fl = FileSystem::getSingleton().Locate(L"SkySphere.mesh", rule);
			Model* sky = new Model(ModelManager::getSingleton().CreateInstance(m_device, fl));
			obj->setModel(0, sky);

			m_scene->AddObject(obj);
		}
	}
	void TerrainDemo::LoadUI()
	{

		Viewport vp = m_device->getViewport();
		int x = vp.Width - 180;
		int y = vp.Height - 120;

		m_cbPushTrees = new CheckBox(Point(x,y), L"", false);
		m_cbPushTrees->SetSkin(m_UIskin);
		m_cbPushTrees->Initialize(m_device);
		m_cbPushTrees->setFontRef(FontManager::getSingleton().getFont(L"comic"));
		m_cbPushTrees->setValue(true);
		
		FileLocation* fl = FileSystem::getSingleton().Locate(L"loading.tex", FileLocateRule::Default);
		m_loadingScreen = TextureManager::getSingleton().CreateUnmanagedInstance(m_device, fl, false);

		fl = FileSystem::getSingleton().Locate(L"helpmove.tex", FileLocateRule::Default);
		m_helpMove = TextureManager::getSingleton().CreateUnmanagedInstance(m_device, fl, false);

		fl = FileSystem::getSingleton().Locate(L"helplook.tex", FileLocateRule::Default);
		m_helpLook = TextureManager::getSingleton().CreateUnmanagedInstance(m_device, fl, false);
	}
	void TerrainDemo::Unload()
	{
		m_sceneRenderer->UnregisterCamera(m_camera);

		
		delete m_sceneRenderer;
		delete m_scene;
		delete m_camera;
		
		for (int i=MinBlockCoord;i<=MaxBlockCoord;i++)
		{
			for (int j=MinBlockCoord;j<=MaxBlockCoord;j++)
			{
				delete m_terrainBlocks[i - MinBlockCoord][j - MinBlockCoord];
			}
		}

		delete m_sprite;



		delete m_cbPushTrees;
		delete m_helpLook;
		delete m_helpMove;


		TerrainMeshManager::getSingleton().Shutdown();
		TerrainMeshManager::getSingleton().FinalizeResources();
		TerrainMeshManager::Finalize();
		Game::Unload();
	}
	void TerrainDemo::Update(const GameTime* const time)
	{
		Game::Update(time);

		// pushing trees. Camera's world coord is converted to chunk space.
		// Once the chunk is found, it will be notified to do the work on trees.
		if (m_allowTakingDownTrees)
		{
			Vector3 camPos = m_camera->getPosition();
			int bx, bz;
			Terrain::GetBlockCoordinate(camPos, bx, bz);

			if (bx >=MinBlockCoord && bz >=MinBlockCoord && bx <= MaxBlockCoord && bz <= MaxBlockCoord)
			{
				Terrain* t = m_terrainBlocks[bx - MinBlockCoord][bz - MinBlockCoord];
				if (t) t->Push(camPos, m_camera->isSprinting() && m_isMoving);
			}
		}

		// the scene will be loaded after sound count down on,
		// to ensure the loading screen shown up before "the application
		// stops responding" if taking too long.
		if (m_sceneContentLoaded>0)
		{
			m_sceneContentLoaded--;
		}
		else if (m_sceneContentLoaded == 0)
		{
			LoadScene();
			// assign this to prevent call LoadScene every update
			m_sceneContentLoaded = -1;
		}
		else if (m_isLoading)
		{
			// the OperationCount from TerrainMeshManager(or other resource manager)
			// is very fluctuant some times.
			// We use a counter to do the trick. If the counter is counting up to a
			// bigg enough value. That means the terrainMeshManager has been idle for some
			// time period. Then the loading screen should gone.
			if (TerrainMeshManager::getSingleton().GetCurrentOperationCount()==0)
				m_zeroOpFrameCounter++;
			if (m_zeroOpFrameCounter>20)
			{
				m_isLoading = false;
			}
		}

		m_camera->Update(time);

		m_scene->Update(time);

		UpdateCamera();
		UpdateUI(time);
	}
	void TerrainDemo::Draw(const GameTime* const time)
	{
		m_device->BeginFrame();

		m_sceneRenderer->RenderScene(m_scene);

		Game::Draw(time);
		
		m_sprite->Begin((Sprite::SpriteSettings)(Sprite::SPR_AlphaBlended | Sprite::SPR_RestoreState));
		DrawUI(m_sprite);


		m_sprite->End();

		m_device->EndFrame();
	}

	void TerrainDemo::OnFrameStart() { }
	void TerrainDemo::OnFrameEnd() { }

	void TerrainDemo::UpdateCamera()
	{
		m_isMoving = false;

		if (!m_isLoading)
		{
			if (!UIRoot::getActiveForm() && !UIRoot::getTopMostForm())
			{
				Keyboard* kb = InputAPIManager::getSingleton().getKeyboard();
				if (kb->IsPressing(KEY_W))
				{
					m_camera->MoveForward();
					m_isMoving = true;
				}
				if (kb->IsPressing(KEY_A))
				{
					m_camera->MoveLeft();
					m_isMoving = true;
				}
				if (kb->IsPressing(KEY_D))
				{
					m_camera->MoveRight();
					m_isMoving = true;
				}
				if (kb->IsPressing(KEY_S))
				{
					m_camera->MoveBackward();
					m_isMoving = true;
				}
				if (kb->IsPressing(KEY_LSHIFT))
					m_camera->Sprint();
				if (kb->IsKeyDown(KEY_SPACE))
					m_camera->Jump();



				Mouse* mouse = InputAPIManager::getSingleton().getMouse();
				if (mouse->IsLeftPressedState())
				{
					m_camera->Turn(mouse->getDX()*0.25f, mouse->getDY()*0.25f);
				}
			}


		}
		

	}
	void TerrainDemo::UpdateUI(const GameTime* const time)
	{
		if (!m_isLoading)
		{
			m_cbPushTrees->Update(time);

			m_allowTakingDownTrees = m_cbPushTrees->getValue();

			if (m_helpShowState<20)
				m_helpShowState += time->getElapsedTime();
			
		}
		
	}

	void TerrainDemo::DrawUI(Sprite* sprite)
	{
		//return;
		int usage = (int)TerrainMeshManager::getSingleton().getUsedCacheSize();
		int total = (int)TerrainMeshManager::getSingleton().getTotalCacheSize();

		int op = TerrainMeshManager::getSingleton().GetCurrentOperationCount();

		Font* fnt = FontManager::getSingleton().getFont(L"comic");
		
		Viewport vp = m_device->getViewport();
		int x = 26;
		int y = vp.Height - (675-480);

		//m_device->getRenderState()->SetAlphaBlend(true, BLFUN_Add, BLEND_SourceAlpha, BLEND_InverseSourceAlpha, 0);

		static const String chinese = L"CALIS 是一个专为语文教学而设计的电脑软件。在当今这个电脑时代，＂电脑辅助教学＂是一个极为教师与学生所喜欢的教学媒体。 因为教学须要注重个别化，每一个学生有其不同的程度，如何有效地针对每一个学生给予不同的反应及立刻的指正，以及最后不同的记分，只有仰赖＂电脑＂去完成。 CALIS 正是扮演了这个角色。不仅减轻了老师的负担与时间，更能兼顾到每一个学生之需要。除此之外，CALIS 提供了生动的学习环境，所以更能激发学生的学习兴趣与动机。 WinCALIS 是 CALIS 的延伸，涵盖了更多的功能。比如：运用视窗 (window) 及滑鼠 (mouse)，让教师及学生更为有效地操作；＂拼音更正 ＂(spelling check) 提供适当的暗示，给予学生思考及改正；在编排课程方面，教师只须在显现的各类视窗中，输入所设计的教材热荨部纬热荨⑽侍狻⒔獯稹⒒蚴遣慰甲柿稀场５缒粤⒓醋远产生 SCRIPTS，教师可以不须具备太多的电脑常识或编写语言 (authoring language) 即可编著课程，让学生使用。 WinCALIS更可以让教师利用激光影碟 (laserdisc)及录像机所产生的生动画面融入教学，让课程更为生动活泼。同时WinCALIS提供了不同语言的键盘输入，用者可以很容易地同时使用多种语言，只需透过滑鼠(mouse)来选择即可从一种语言到另一种语言。 由于 CALIS具备了容易及灵活使用的本质，使得它已经成为 90 年代电脑辅助教学(CAI)的标准。 CALIS的第二具备了中文文书处理的功能。它不仅可以编写，也可以印出。您手边的这份文件即是用CALIS 编印出来的。";

		fnt->DrawString(m_sprite, chinese, 0,0, vp.Width, CV_White);

		fnt->DrawString(m_sprite, L"Operations: " + StringUtils::ToString(op), Point(x,y), CV_White);
		y+=35;
		fnt->DrawString(m_sprite, L"Cache Usage: " + StringUtils::ToString(usage/1048576) + L"/" + StringUtils::ToString(total/1048576) + L"MB", Point(x,y), CV_White);
		y+=35;
		fnt->DrawString(m_sprite, L"Batch Count: " + StringUtils::ToString(m_device->getBatchCount()), Point(x,y), CV_White);
		y+=35;
		fnt->DrawString(m_sprite, L"Primitive Count: " + StringUtils::ToString(m_device->getPrimitiveCount()), Point(x,y), CV_White);
		y+=35;
		fnt->DrawString(m_sprite, L"FPS: " + StringUtils::ToString(m_window->getFPS(), 0, 0), Point(x,y), CV_White);

		x = vp.Width - 180;
		y = vp.Height - 120;
		m_cbPushTrees->Position = Point(x,y);
		m_cbPushTrees->Draw(sprite);

		x+= 30;
		y-= 7;
		fnt->DrawString(m_sprite, L"Push Trees", Point(x,y), CV_White);


		if (m_isLoading)
		{
			Apoc3D::Math::Rectangle dstRect(vp.X, vp.Y, vp.Width, vp.Height);
			m_sprite->Draw(m_loadingScreen, dstRect, CV_White);
		}


		x = vp.Width - 400;
		y = 100;

		// m_helpShowState, an accumulated time, is used to calculate the alpha value of the help instruction
		// images using the mapping below.
		// These are also used in terrain texturing in the pixel shader.
		float moveBlend = 1- Math::Saturate(2*  fabs(m_helpShowState - 5)/4.5f-1);
		float lookBlend = 1- Math::Saturate(2*  fabs(m_helpShowState - 15)/4.5f-1);

		uint moveAlpha = (uint)(255 * moveBlend);
		uint lookAlpha = (uint)(255 * lookBlend);

		if (moveAlpha>0)
		{
			m_sprite->Draw(m_helpMove, x,y , PACK_COLOR(0xff,0xff,0xff,moveAlpha));
		}
		if (lookAlpha>0)
		{
			m_sprite->Draw(m_helpLook, x,y , PACK_COLOR(0xff,0xff,0xff,lookAlpha));
		}
		
	}
}